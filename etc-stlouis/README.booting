*** Precompliance Fieldwork Special Edition Notes ***

You will need:

- A Gimlet rev B, reworked to BE07 (with processor and DRAM)
- The loader, kernel, and ramdisk images in wesolows/precompliance-software at
  https://drive.google.com/drive/folders/1TPLa9Vp26485kZjLx4i_CMVwWvNo1wbb
- An ST-Link connection to the SP, SP software, and matching humility
- A connection to the SP3 side of the UART0 header
- One of these collections of things:
  * <A> At least one M.2 NVMe SSD and an Intel I210 or 82574 NIC, or
  * <B> An Intel I210 or 82574 NIC
  * <C> At least one M.2 NVMe SSD and an external laptop-driven programmer, or

These notes assume you know how to connect up the ST-Link and UART.  There is
nothing special required there.  You need to decide up front whether you are
following path <A>, <B>, or <C> based on what hardware devices you have
available to you from the list above.  These paths will be referenced
throughout the setup instructions.  If you are following paths <A> or <C>, you
will be given the option to persist phase2 software, saving time and steps if
you need to reboot later.

Prompts
-------
In the examples below, each prompt style indicates where the specified command
is to be run:

	$	laptop connected to the Gimlet
	>	Gimlet bootloader
	[0]>	Gimlet kmdb
	#	Gimlet userland, logged in as root

Steps
-----

If you have already performed steps 0-5 on this Gimlet, skip to step 6.

0. Write down the manufacturer and serial number of each SSDs you wish to use
prior to or during installation; they can usually be found on the label.  This
will make it easier to identify the device you want to use once the system is
running.

1. If you are not following path <C>, skip to step 2.

If you are following path <C> above, on your laptop, copy the 'phase2.tar'
file onto the raw SSD device.  This will be similar to using the SSD like a
tape drive and avoids any requirement to have ZFS tools on your laptop.

If you need to install additional software and will not have Ethernet access
to the Gimlet later on, you will need to find a way to get it onto this SSD at
the same time.  The easiest way to do this is to append the files you need
onto 'phase2.tar' prior to copying it onto the SSD.  You can do so assuming
you have a working tar(1) on your laptop with something like:

   $ tar uf phase2.tar some_file other_file whatever_you_need

Assuming you are using a USB-to-NVMe converter and your laptop runs GNU/Linux,
the SSD will be called something like
/dev/disk/by-id/usb-_Micron_00A0750130082D21-0:0.  You may need to use sudo or
some other privilege escalator to do this; the exact details are specific to
your OS and installation.  On Arch GNU/Linux, I would do something like:

   $ ls /dev/disk/by-id
   (identify the correct device to use)
   $ sudo dd if=phase2.tar of=/dev/disk/by-id/usb-_Micron_00A0750130082D21-0:0
       bs=1024k

Remove the SSD.

2. If you are following path <B> and do not have an SSD, skip to step 3.
Otherwise, install the SSD in your Gimlet.  You may use any socket into which
the SSD fits.

3. If you are following paths <A> or <B>, or you are following path <C> and
also want gigabit copper networking, install your NIC in one of the sharkfin
PCIe sockets (I recommend J).  Otherwise, skip to step 4.

You will need to remove the outer top case panel and the inner top sharkfin
retainer bracket from the Gimlet, and the back CEM mounting plate from the
NIC.  Note that half-height CEM AICs are slightly too tall for the inner top
sharkfin retainer bracket, so you may need to tilt the NIC slightly to
reinstall the retainer bracket.  It is easiest to attach the Ethernet cable to
the NIC while the machine is still open; route it out the front of the empty
U.2 bay.  Make sure any sharkfins you are going to populate have their top
retaining keys seated in the retainer bracket before reinstalling the outer
top panel.

4. Connect up your Gimlet and turn it on.

5. Burn the special loader image (milan-quiet-3m-2dpc-0.4.5-128MiB.bin):

   $ humility qspi -W milan-quiet-3m-2dpc-0.4.5-128MiB.bin

6. Enter power state A0:

   $ humility hiffy -c Sequencer.set_state -a state=A0

7. The loader should identify itself as

   Nano-Bootloader 0.4.5-128MiB

If it does not, drop to A2 and go back to step 5 and burn the correct image.

   $ humility hiffy -c Sequencer.set_state -a state=A2

8. If you have any M.2 SSDs installed, work around the M.2 power control bug
by forcing the controller on.  If both sockets are populated:

   $ humility i2c -b mid -d 0x3a -r 0x3b -w 0x0f

If only socket A is populated, write 0x0e; if only socket B is populated,
write 0xd.

9. Load the ramdisk in the usual fashion:

   > 101000000::recv -m
   (initiate an Xmodem-1K send of 'ramdisk.oxide.ufs' from your laptop)

10. Load and boot the kernel in the usual fashion:

   > 100000000::recv -m | ::load | ::call
   (initiate an Xmodel-1K send of 'unix.oxide' from your laptop)

11. Continue booting after reaching the initial kmdb prompt:

   [0]> :c

12. Upon reaching userland, log in as root.  There is no password.

13. If you installed the NIC in step 3, start up networking now.  Otherwise,
skip to step 14.

DHCP is not supported; you will need to choose an IP address that matches the
network in use on your laptop or other attached devices.  For example, if you
have configured your laptop's NIC to use 192.168.171.1/24, you can put the
Gimlet at 192.168.171.2/24 as follows:

   # /root/start-network 192.168.171.2/24

If you have installed multiple NICs or are in a state where the T6 is already
in mission mode, you may need to specify the datalink you wish to use.  An
I210 will be named igbN (where N is an integer index starting at 0) and an
82574 e1000gN.  To see the available NICs, you can use:

   # dladm show-link

By default, start-network will use the first link in the list.  This is just a
crappy shell script (as are most of the rest of the steps) so you can look at
what it's doing by:

   # cat /root/start-network

If you need access to the Internet (or other networks) from the Gimlet, you
can add static routes as required at this point; for example,

   # route add default 192.168.171.1

Make sure the Gimlet and your laptop (or other necessary hosts) can
communicate:

   # ping 192.168.171.1
   $ ping 192.168.171.2

You should also be able to reach the Gimlet using ssh:

   $ ssh root@192.168.171.2

14. If your Gimlet doesn't have any M.2 SSDs installed, skip to step 15.  If
you do have one or more M.2 SSDs, it's time to get them working.  Start with:

   # nvmeadm list

Ideally, all SSDs in the machine will appear in this list; for example, with 2
of each form factor installed, you might see:

nvme3: model: Micron_7300_MTFDHBG1T9TDF, serial: 203130082CFB, FW rev: 95420260, NVMe v1.3
  nvme3/00a0750130082cfb (c4t00A0750130082CFBd0): Size = 1831420 MB, Capacity = 1831420 MB, Used = 1831420 MB
nvme0: model: Micron_7300_MTFDHBG1T9TDF, serial: 203130082D21, FW rev: 95420260, NVMe v1.3
  nvme0/00a0750130082d21 (c1t00A0750130082D21d0): Size = 1831420 MB, Capacity = 1831420 MB, Used = 1831420 MB
nvme1: model: WUS4C6432DSP3X3, serial: A079E06E, FW rev: R2210000, NVMe v1.3
  nvme1/0014ee81000bc21a (c2t0014EE81000BC21Ad0): Size = 3052360 MB, Capacity = 3052360 MB, Used = 3052360 MB
nvme2: model: WUS4C6432DSP3X3, serial: A079E264, FW rev: R2210000, NVMe v1.3
  nvme2/0014ee81000bc37c (c3t0014EE81000BC37Cd0): Size = 3052360 MB, Capacity = 3052360 MB, Used = 3052360 MB

More likely, you will see that the SSD in M.2 socket A is missing (assuming
you have anything installed in it).  If so, you must work around stlouis#57 by
running:

   # /root/fix-m2a

This program will instruct you to execute a pair of humility commands on your
laptop that will cycle the power to M.2A.  When you have completed these
commands, press <ENTER> to finish the workaround.  At this point, all
installed SSDs should be visible via 'nvmeadm list'.  If not, you will need to
stop and debug the problem.

16. If you have previously chosen to persist phase2 data onto an installed
SSD, skip to step 19.  Otherwise, if you are following paths <A> or <B>, skip
to step 17.  If you are following path <C>, save your phase2 software into
/tmp.  First you must identify the SSD on which you previously stored the
software.  You can examine the SSDs' metadata using nvmeadm's 'list' and
'info' subcommands:

   # nvmeadm list
   # nvmeadm identify nvme2

When you have identified the correct device to use, note/copy its device path,
which will be something like 'c1t00A0750130082D21d0'.  Then extract the phase2
software you previously stored in step 1:

   # cd /tmp
   # tar xf /dev/dsk/c1t00A0750130082D21d0

You should now see several directories in /tmp, among them 'usr'.  If not, or
if this command fails, most likely you have chosen the wrong SSD.  Go back to
the beginning of this step and find the correct one, then perform the
extraction.

17. If you are following paths <A> or <B>, it is time to transfer the phase2
software onto the Gimlet over the network; be sure to substitute the IP
address you configured in step 13:

   $ scp phase2.tar root@192.168.171.2:/tmp

Make sure the file is present:

   # ls /tmp/phase2.tar

Extract the contents:

   # cd /tmp
   # tar xf phase2.tar

18. At this point, regardless of which path you are following, you should have
phase2 software unpacked in /tmp and, if you installed a NIC, access to your
Gimlet over Ethernet.  If you have an SSD installed (paths <A> or <C>), you
have the option of persisting your phase2 software onto the SSD.  Doing this
will allow you to skip steps 16, 17, and 18 on subsequent boots provided you
leave that SSD installed.  If you don't have an SSD installed or don't want to
persist phase2 software, skip to step 19.  Otherwise, start by creating a pool
and filesystem on the SSD you wish to use (see step 16 for notes on
identifying SSDs; if you are following path <C> you can overwrite the data on
the SSD you used in previous steps, or use a different one):

   # zpool create -f boot /dev/dsk/c1t00A0750130082D21d0
   # zfs create boot/phase2

Copy the phase2 data from /tmp:

   # cp -rP /tmp /boot/phase2

19. Finally, set up your environment to use phase2 software.  The
/root/post-phase2 script takes an argument specifying the location of phase2
software; if you chose to persist that software, it is located in /boot/phase2
(or whatever location you chose in step 18); otherwise, it is located in /tmp:

   # /root/post-phase2 /boot/phase2

This will set up the runtime linker and root's PATH so that phase2 software
can (usually) be found.  It will also use coreadm to save any cores that are
dumped; please save any such cores and file bugs accordingly.  The script will
instruct you to either log out and back in or to source /root/.profile to set
up your PATH properly.  Once you have done so, you have access to all phase2
software.  You can configure additional persistent data storage (such as
creating a pool on U.2 SSDs), plumb up the T6 and/or Sidecar links, and
whatever else you need to do.  If you need to load additional software, I
recommend creating a filesystem and mounting it at /opt/local; by default,
/opt/local/bin is in root's PATH and executables can be installed there.  You
may need to use crle(8) if you need to install libraries in /opt/local/lib.
In general, at this point the Gimlet behaves much like any other illumos
system; consult the manual as needed.  Note that you cannot write to /usr, but
you can use lofs(7fs) to mount over unused files and directories there.
Changes made to the root filesystem (/, /etc, /root, ...) will not persist
even if you set up persistent phase2 storage; the root filesystem is part of
phase1.

T6 Setup
--------

TBD

Sidecar Setup
-------------

TBD

*** Original Notes for illumos Engineers ***

Steps:

1. Build the kernel, modules, and kmdb and its dependencies.  The kmdb deps
are a pain if you haven't set up a bunch of ancillary crap to build userland
(in particular, Python.h seems to come up a lot).  If you have nightly(1onbld)
working, that should work fine for building all the modules you need.  If you
want to build on an arbitrary build machine using adjuncts, consider applying
illumos-build-fixes.diff from this directory.

2. Build a ramdisk.  The size in mkrd.bash must match the end address property
value in usr/src/uts/oxide/os/boot_data.c; if you need to grow the ramdisk,
change both of these!  This program outputs the name of the ramdisk image; it
uses a temporary name because even though these are internal build machines
and basically single-user we try to avoid glaring security holes; if you want
to use a fixed name you can do something like:

	$ mv $(./mkrd.bash) /path/to/ramdisk.ufs

3. Build nanobl-rs and burn it to your test machine's boot flash.  See the
instructions in that repo's README.

4. At this point you should have:
	- A box sitting at the > prompt in your terminal emulator (see
	  nanobl-rs repo for notes on configuring it)
	- A copy of unix from $ROOT/platform/kernel/oxide/amd64/unix
	- A copy of ramdisk.ufs or whatever you called it

Note that we currently need unix in the ramdisk and outside it; this
requirement can eventually be relaxed because we actually have the ELF image
in memory and the loader could tell krtld where to find it to look up symbols.
That will save about 2 MiB in the image, but for now you need it twice, and
the file in the ramdisk MUST MATCH the kernel you boot; otherwise krtld will
complain and you will not get very far.

5. If you are using a rev A Gimlet and want a NIC and/or SSD(s), you must now
power on any sharkfin power controllers you need, then release PERST# for each
PCIe end device you wish to use.  Releasing PERST# requires hardware
modification; ask if you don't know what to do.  These steps may be done in
parallel with ramdisk loading (next step).

6. Now issue the following sequence of loader commands:

	> 101000000::recv -m

	Send the ramdisk you built previously via your terminal emulator's
Xmodem upload command at this time.  This command places the ramdisk into
memory at 1_0100_0000, which must match the address in oxide/os/boot_data.c.
Note that if you build a ramdisk larger than 64 MiB, you will also need to map
memory manually or specify the size in bytes on the loader command line.  See
the help for ::recv's -m option.

	> 100000000::recv -m | ::load | ::call

	Send unix in the same manner at this time.  You are free to put this
almost anywhere that the loader will let you, except for the area the ramdisk
already occupies and the regions the kernel itself wants to be loaded into.
The suggested address is convenient and out of the way and should work on
every supportable Gimlet and Ethanol-X.  When the file receiption completes,
::load and ::call will interpret the kernel and an ELF object and transfer
control to its entry point, booting the OS.  NOTE: This syntax is available
only in nanobl-rs 0.4.1 and later.  If you have 0.4.0, you can still boot but
will need to issue three separate commands instead of a single pipeline.

6. If you wish to proceed to userland, utter ':c' when kmdb loads, ignoring
any errors about failure to load kmods.  Otherwise, begin your debug session.

7. Upon reaching userland, if you have a NIC you can plumb up your network
links and routes, then utter '/root/start-sshd' to gain remote access.  The
collection of available phase-1 system software is very limited and heavily
skewed toward debugging tools.  If you want a more functional (RFD 241
"phase-2") system, build yourself a tarball from your proto area by doing
something like:

	$ cd $ROOT; tar cf phase2.tar kernel/drv kernel/fs kernel/misc \
	  usr/lib/devfsadm usr/bin usr/lib/lib* usr/lib/amd64/lib* usr/sbin \
	  kernel/strmod sbin/zpool sbin/zfs usr/xpg6/bin usr/lib/cfgadm \
	  lib/lib* lib/amd64/lib* lib/64 usr/lib/64 usr/lib/security
	$ scp phase2.tar root@gimlet:/tmp
	gimlet:~# cd /tmp && tar xpf phase2.tar
	gimlet:~# /root/post-phase2

The root user's environment is set up so that the stuff in /tmp/bin and so
forth will be on the PATH and libraries can generally be found.  You can of
course add or change the contents to suit your needs; the above will be enough
to give you working zpool and zfs commands so if you have storage you can now
create or import a pool, making it convenient to persist data across reboots
for debugging or V&V, store larger toolsets, etc.  All of this is definitely
not complete or perfect and some things probably still won't work; you are at
the end of the graded road so grab your illumos man pages and work it out for
yourself.

8. If you wish to re-enter kmdb, send a BREAK using your terminal emulator
(picocom default: C-a C-|).  There is currently no way to reboot.  On Gimlet,
use humility to cycle through A2.  On Eth-X, ipmitool or the web UI may be
used.

Next steps:

There are many, many things to do next, and the good news is that there is
enough parallelism here for 8-10 engineers.  A few examples:

- Unmap the loader's text, data, and miscellany.  At present, we know where
  the pagetables and earlyboot stack are, and the loader has set bit 11 in all
PTEs for the kernel, so we should be able to delete these mappings if we wish.
Regardless, they end up getting unmapped and the underlying pages freed later
in boot.

- Figure out how to turn off the three reserved regions of RAM the PSP wants.

- Set the magic undocumented MSRs for the BSP, and add code to MP startup to
  do it on APs once we get there.  This probably belongs in apix, which is a
much bigger can of worms.

- Fix up the boot time properties code so we can accept the root pointer as a
  physical address, or decide that we don't ever want the loader passing boot
properties and just have it pass the ramdisk location.  There are several ways
to do this and we should take a little time to think it through -- in
particular, how offsets/pointers internally to the properties are represented.
Doing 1275 is an option here though a read through that standard suggests far
more complexity than we want or need.

- Replace boot_data.c with RPC calls to the SP.

- We can remove more of the bootaux code if we want.  The kernel's ELF object
  is in memory, and we could have the loader tell us where it is if we wanted
to.  If we were clever we could even dispense with copying the contents and
just load it in the right place, then create the proper mappings.  You know,
like a loader.  See the notes above on step 4.

- Switch us to a compressed CPIO ramdisk.  We're certain to need it to save
  space, and probably time.  Even with just gzip, the existing 13 MiB ramdisk
that is very nearly enough to get to userland fits in about 4 MiB compressed,
which is shockingly comparable to LinuxBoot, though it doesn't include any
actual user programs.  This also offers us another path to simplify booting
into a single step, by including the kernel and having the loader extract it
from the archive instead of making them separate steps; we wouldn't want to
make the loader understand UFS but CPIO might be ok.

- Probably rewrite mlsetup(), which is needlessly complicated for our needs.

- Commonise the rest of the microcode updating code.  Being able to upgrade
  microcode will be one of the very first things we want to do, so we don't
chase ghosts once we have single-user up.

- Commonise (most?  all?) the x86 HAT code.  This is current machine arch
  specific but most of it is really not.  This is in fact the same thing they
found with SPARC when they created the sfmmu directory.

- Audit and remove all the -Nmisc/acpica and other -Ndrv/acpidrv etc.
  arguments.  This should be quick and simple, but removing the code that
actually consumes these interfaces won't be.  In most cases that code needs to
be rewritten entirely but that needs to be audited on a case by case basis;
there are likely to be places where we want to share most code that currently
consumes ACPI and it may be good to create a set of ops vectors or whatever
that allow generic consumers to use ACPI or go direct (similar to platmod/PSM,
probably, or we may even be able to just extend that interface to cover
multiple machine architectures).

- Delete the rebooting code, which doesn't work anyway.  Negotiate a
  communication mechanism with the SP that can be used to request a reset from
both earlyboot and a normal working system (i.e., this can't rely solely on
STREAMS or something like that).  Stuff like `pc_reset` needs to move to
i86pc.
