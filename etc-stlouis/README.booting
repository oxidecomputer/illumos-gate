You will need:

- A supportable Gimlet, or an Ethanol-X (for now), with Milan processor(s)
- illumos-gate stlouis a368956d97835cacf0266ab9ff2fe7b7944afa09 or later
- nanobl-rs 0.5.0 or later (0.4.1 and later will work but will require manual
  steps and will not provide compressed image support; check out older
  versions of this file for instructions on old loaders)
- A built stlouis workspace
- The tools in this directory

External Links
--------------
Lab machine guide:
https://github.com/oxidecomputer/meta/blob/master/engineering/lab/gimlet.adoc

Setting up and using a helios-dev build machine:
https://github.com/oxidecomputer/stlouis/blob/main/dev.adoc

Steps:

1. Build the kernel, modules, and kmdb and its dependencies.  If you aren't
sure how to do this, don't know what adjuncts are, or just want the simplest
possible HOWTO, you are or probably want to be on helios-dev and should follow
https://github.com/oxidecomputer/stlouis/blob/main/dev.adoc.  Otherwise it is
assumed that you have a working build environment and know how to build what's
needed on your distribution using the in-gate tools.  If you want to build on
an arbitrary build machine using adjuncts, consider applying
illumos-build-fixes.diff from this directory which fixes several upstream bugs
that interfere with reproducible builds.  You don't need this patch if you are
not doing a reproducible build (again, if you aren't sure, just follow
https://github.com/oxidecomputer/stlouis/blob/main/dev.adoc).

IMPORTANT: If you are booting a phase-1 ramdisk over the UART (following the
instructions in this file), you must comment out or delete the line defining
OXIDE_UNIFIED_BOOT before building.  Otherwise, the default build for this
branch will produce a kernel that expects to boot using the phase1+phase2 boot
image from disk or over the network, and it will panic late in boot if you
follow these instructions.

2. Build a ramdisk.  The size in mkrd.bash must match the end address property
value in usr/src/uts/oxide/os/boot_data.c; if you need to grow the ramdisk,
change both of these!  This program outputs the name of the ramdisk image; it
uses a temporary name because even though these are internal build machines
and basically single-user we try to avoid glaring security holes; if you want
to use a fixed name you can do something like:

	$ mv $(./mkrd.bash) /path/to/ramdisk.ufs

3. Compress your ramdisk (optionally, you may also compress your kernel).
Unfortunately, gzip is not appropriate; instead use
https://github.com/oxidecomputer/pinprick or the python code in
https://github.com/oxidecomputer/nanobl-rs/pull/89#issue-1301450517:

	$ pinprick /path/to/ramdisk.ufs > /path/to/ramdisk.ufs.z

4. Start your terminal emulator and attach it to the target machine's UART0.
The examples here assume you use picocom, but you can use whatever you like.

	// For lab systems:
	$ pfexec humility -t <target> exec console
	// In general:
	$ picocom -s "sx -Xk" --flow h -b 3000000 --imap lfcrlf --omap \
	crlf,delbs /dev/my/local/uart

5. If you haven't done so already, build nanobl-rs and burn it to your test
machine's boot flash.  See the instructions in that repo's README.  Put the
test machine into A0:

	// Image burn if needed; lab systems need pfexec + -t <target>
	$ humility qspi -D ~/src/amd-host-image-builder/milan-gimlet-b.img
	// Power up; lab systems need pfexec + -t <target>
	$ humility hiffy -c Sequencer.set_state -a state=A0

Note that you need to be in A2 first to burn the flash.  If you are using
Ethanol-X, see the manual for your workstation's IPMI client tools and the
Ethanol-X BMC firmware.

6. At this point you should have:
	- A box sitting at the throbber or > prompt in your terminal emulator
	(see nanobl-rs repo for notes on configuring it)
	- A copy of unix from $ROOT/platform/kernel/oxide/amd64/unix
	- A copy of ramdisk.ufs or whatever you called it

Note that we currently need unix in the ramdisk and outside it; this
requirement can eventually be relaxed because we actually have the ELF image
in memory and the loader could tell krtld where to find it to look up symbols.
That will save about 2 MiB in the image, but for now you need it twice, and
the file in the ramdisk MUST MATCH the kernel you boot; otherwise krtld will
complain and you will not get very far.

7. If you are using a rev A Gimlet and want a NIC and/or SSD(s), you must now
power on any sharkfin power controllers you need, then release PERST# for each
PCIe end device you wish to use.  Releasing PERST# requires hardware
modification; ask if you don't know what to do.  These steps may be done in
parallel with ramdisk loading (next step).

8. Now issue the following sequence of loader commands.  First, instruct
nanobl-rs to receive the ramdisk:

	> 110000000::recv -m | ::inflate 101000000

nanobl-rs will block, silently waiting for data to arrive.  You should now use
your terminal emulator's Xmodem send command to transfer the compressed
ramdisk you build in step 3.  On picocom, this is C-a C-s.

This command places the ramdisk into memory at 1_0100_0000, which must match
the address in oxide/os/boot_data.c.  Note that if you build a ramdisk larger
than 128 MiB, you will also need to map memory manually or specify the size in
bytes on the loader command line.  See the help for ::recv's -m option and
::inflate.

Next, instruct nanobl-rs to receive unix in the same manner, and to begin
executing the kernel once the transfer completes.  If you compressed your
kernel in step 3, utter:

	> 110000000::recv -m | ::inflate 100000000 | ::load | ::call

If you did not compress your kernel:

	> 100000000::recv -m | ::load | ::call

Again, as soon as nanobl-rs blocks, use Xmodel to send unix.z (or unix) to the
target machine (picocom: C-a C-s).

The addresses used for unix in the above example are almost entirely
arbitrary, but should work on any machine we have.  When the file receiption
completes, ::load and ::call will interpret the kernel and an ELF object and
transfer control to its entry point, booting the OS.

9. If you wish to proceed to userland, utter ':c' when kmdb loads, ignoring
any errors about failure to load kmods.  Otherwise, begin your debug session.

10. Upon reaching userland, if you have a NIC you can plumb up your network
links and routes, then utter '/root/start-sshd' to gain remote access.  The
collection of available phase-1 system software is very limited and heavily
skewed toward debugging tools.  If you want a more functional (RFD 241
"phase-2") system, build yourself a tarball from your proto area by doing
something like:

	$ cd $ROOT; tar cf phase2.tar kernel/drv kernel/fs kernel/misc \
	  usr/lib/devfsadm usr/bin usr/lib/lib* usr/lib/amd64/lib* usr/sbin \
	  kernel/strmod sbin/zpool sbin/zfs usr/xpg6/bin usr/lib/cfgadm \
	  lib/lib* lib/amd64/lib* lib/64 usr/lib/64 usr/lib/security usr/lib/fm
	$ scp phase2.tar root@gimlet:/tmp
	gimlet:~# cd /tmp && tar xpf phase2.tar
	gimlet:~# /root/post-phase2

The root user's environment is set up so that the stuff in /tmp/bin and so
forth will be on the PATH and libraries can generally be found.  You can of
course add or change the contents to suit your needs; the above will be enough
to give you working zpool and zfs commands so if you have storage you can now
create or import a pool, making it convenient to persist data across reboots
for debugging or V&V, store larger toolsets, etc.  All of this is definitely
not complete or perfect and some things probably still won't work; you are at
the end of the graded road so grab your illumos man pages and work it out for
yourself.

11. If you wish to re-enter kmdb, send a BREAK using your terminal emulator
(picocom default: C-a C-|).  There is currently no way to reboot.  On Gimlet,
use humility to cycle through A2.  On Eth-X, ipmitool or the web UI may be
used.

Next steps:

There are many, many things to do next, and the good news is that there is
enough parallelism here for 8-10 engineers.  A few examples:

- Unmap the loader's text, data, and miscellany.  At present, we know where
  the pagetables and earlyboot stack are, and the loader has set bit 11 in all
PTEs for the kernel, so we should be able to delete these mappings if we wish.
Regardless, they end up getting unmapped and the underlying pages freed later
in boot.

- Figure out how to turn off the three reserved regions of RAM the PSP wants.

- Fix up the boot time properties code so we can accept the root pointer as a
  physical address, or decide that we don't ever want the loader passing boot
properties and just have it pass the ramdisk location.  There are several ways
to do this and we should take a little time to think it through -- in
particular, how offsets/pointers internally to the properties are represented.
Doing 1275 is an option here though a read through that standard suggests far
more complexity than we want or need.

- Replace boot_data.c with RPC calls to the SP.

- We can remove more of the bootaux code if we want.  The kernel's ELF object
  is in memory, and we could have the loader tell us where it is if we wanted
to.  If we were clever we could even dispense with copying the contents and
just load it in the right place, then create the proper mappings.  You know,
like a loader.  See the notes above on step 4.

- Switch us to a compressed CPIO ramdisk.  This is currently under way in a
  new flash-only loader called phbl.

- Probably rewrite mlsetup(), which is needlessly complicated for our needs.

- Commonise the rest of the microcode updating code.  Being able to upgrade
  microcode will be one of the very first things we want to do, so we don't
chase ghosts once we have single-user up.

- Commonise (most?  all?) the x86 HAT code.  This is current machine arch
  specific but most of it is really not.  This is in fact the same thing they
found with SPARC when they created the sfmmu directory.

- Audit and remove all the -Nmisc/acpica and other -Ndrv/acpidrv etc.
  arguments.  This should be quick and simple, but removing the code that
actually consumes these interfaces won't be.  In most cases that code needs to
be rewritten entirely but that needs to be audited on a case by case basis;
there are likely to be places where we want to share most code that currently
consumes ACPI and it may be good to create a set of ops vectors or whatever
that allow generic consumers to use ACPI or go direct (similar to platmod/PSM,
probably, or we may even be able to just extend that interface to cover
multiple machine architectures).

- Delete the rebooting code, which doesn't work anyway.  Negotiate a
  communication mechanism with the SP that can be used to request a reset from
both earlyboot and a normal working system (i.e., this can't rely solely on
STREAMS or something like that).  Stuff like `pc_reset` needs to move to
i86pc.
