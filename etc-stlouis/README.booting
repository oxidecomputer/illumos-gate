*** Precompliance Fieldwork Special Edition Notes ***

You will need:

- A Gimlet rev B, reworked to BE07 (with processor and DRAM)
- The loader, kernel, and ramdisk images in wesolows/precompliance-software at
  https://drive.google.com/drive/folders/1TPLa9Vp26485kZjLx4i_CMVwWvNo1wbb
- An ST-Link connection to the SP, SP software, and matching humility
- A connection to the SP3 side of the UART0 header
- One of these collections of things:
  * <A> At least one M.2 NVMe SSD and an Intel I210 or 82574 NIC, or
  * <B> An Intel I210 or 82574 NIC
  * <C> At least one M.2 NVMe SSD and an external laptop-driven programmer, or

These notes assume you know how to connect up the ST-Link and UART.  There is
nothing special required there.  You need to decide up front whether you are
following path <A>, <B>, or <C> based on what hardware devices you have
available to you from the list above.  These paths will be referenced
throughout the setup instructions.  If you are following paths <A> or <C>, you
will be given the option to persist phase2 software, saving time and steps if
you need to reboot later.

Prompts
-------
In the examples below, each prompt style indicates where the specified command
is to be run:

	$	laptop connected to the Gimlet
	>	Gimlet bootloader
	[0]>	Gimlet kmdb
	#	Gimlet userland, logged in as root

Steps
-----

WARNING: You must always start in power state A3 or lower due to
hardware-gimlet#1701.  If you start in A2 after a previous boot, behaviour of
PCIe devices may be unpredictable.  Sometimes this can be fixed with the
sequence of steps performed by the "fix-m2a" and "fix-t6" scripts, with
appropriate adjustments for the specific device's power and reset control.
Sometimes not.  Since we don't really have Ignition control and it's unclear
whether all host-visible rails really go to 0V in A3, ALWAYS START IN A4.
This means removing the Gimlet from the bus bar or turning off the attached
Meanwell supply, then waiting for all rails to bleed to 0V before proceeding.

If you have already performed steps 0-5 on this Gimlet, skip to step 6.

0. Write down the manufacturer and serial number of each SSDs you wish to use
prior to or during installation; they can usually be found on the label.  This
will make it easier to identify the device you want to use once the system is
running.

1. If you are not following path <C>, skip to step 2.

If you are following path <C> above, on your laptop, copy the 'phase2.tar'
file onto the raw SSD device.  This will be similar to using the SSD like a
tape drive and avoids any requirement to have ZFS tools on your laptop.

If you need to install additional software and will not have Ethernet access
to the Gimlet later on, you will need to find a way to get it onto this SSD at
the same time.  The easiest way to do this is to append the files you need
onto 'phase2.tar' prior to copying it onto the SSD.  You can do so assuming
you have a working tar(1) on your laptop with something like:

   $ tar uf phase2.tar some_file other_file whatever_you_need

Assuming you are using a USB-to-NVMe converter and your laptop runs GNU/Linux,
the SSD will be called something like
/dev/disk/by-id/usb-_Micron_00A0750130082D21-0:0.  You may need to use sudo or
some other privilege escalator to do this; the exact details are specific to
your OS and installation.  On Arch GNU/Linux, I would do something like:

   $ ls /dev/disk/by-id
   (identify the correct device to use)
   $ sudo dd if=phase2.tar of=/dev/disk/by-id/usb-_Micron_00A0750130082D21-0:0
       bs=1024k

Remove the SSD.

2. If you are following path <B> and do not have an SSD, skip to step 3.
Otherwise, install the SSD in your Gimlet.  You may use any socket into which
the SSD fits.

3. If you are following paths <A> or <B>, or you are following path <C> and
also want gigabit copper networking, install your NIC in one of the sharkfin
PCIe sockets (I recommend J).  Otherwise, skip to step 4.

You will need to remove the outer top case panel and the inner top sharkfin
retainer bracket from the Gimlet, and the back CEM mounting plate from the
NIC.  Note that half-height CEM AICs are slightly too tall for the inner top
sharkfin retainer bracket, so you may need to tilt the NIC slightly to
reinstall the retainer bracket.  It is easiest to attach the Ethernet cable to
the NIC while the machine is still open; route it out the front of the empty
U.2 bay.  Make sure any sharkfins you are going to populate have their top
retaining keys seated in the retainer bracket before reinstalling the outer
top panel.

4. Connect up your Gimlet and turn it on, entering power state A2.

5. Burn the special loader image (milan-quiet-3m-2dpc-0.4.5-128MiB-lgmmio.bin):

   $ humility qspi -W milan-quiet-3m-2dpc-0.4.5-128MiB-lgmmio.bin

6. Enter power state A0:

   $ humility hiffy -c Sequencer.set_state -a state=A0

7. The loader should identify itself as

   Nano-Bootloader 0.4.5-128MiB

If it does not, drop to A4, go back to step 4, and burn the correct image.

8. Skip to step 9.  Do not perform this step if starting from A4; it is not
needed.  If you have no choice but to start from a previously-booted system in
A2, this step is left here for reference as you may need to perform it.

If you have any M.2 SSDs installed, you may need to work around an M.2 power
control bug by forcing the controller on.  This should not be necessary if you
have started from A4.  If both sockets are populated:

   $ humility i2c -b mid -d 0x3a -r 0x3b -w 0x0f

If only socket A is populated, write 0x0e; if only socket B is populated,
write 0xd.  If you have M.2 sockets populated and they appear to be empty,
this may solve the problem for you.

9. Load the ramdisk in the usual fashion:

   > 101000000::recv -m
   (initiate an Xmodem-1K send of 'ramdisk.oxide.ufs' from your laptop)

10. Load and boot the kernel in the usual fashion:

   > 100000000::recv -m | ::load | ::call
   (initiate an Xmodel-1K send of 'unix.oxide' from your laptop)

11. Continue booting after reaching the initial kmdb prompt.  IMPORTANT: If
you have already programmed your T6 and would like it to work, this is a good
opportunity to toggle the GPIO to enable mission mode; see the section on T6
setup below.  Otherwise, just continue:

   [0]> :c

12. Upon reaching userland, log in as root.  There is no password.

13. If you installed the NIC in step 3, start up networking now.  Otherwise,
skip to step 14.

First, if you are starting from A4, it is likely that your NIC is not yet
powered up.  See the section below entitled "Setting Up PCIe Devices".
Identify the slot in which you installed the NIC and verify that it is
present.  If you did not start in A4, your NIC may be in the broken state and
you will need to manually perform the disconnect/cycle/configure dance
described in that section, which may or may not work.  Otherwise, your NIC may
be in the off state.  In either case, you must get it into the working state
before proceeding.

DHCP is not supported; you will need to choose an IP address that matches the
network in use on your laptop or other attached devices.  For example, if you
have configured your laptop's NIC to use 192.168.171.1/24, you can put the
Gimlet at 192.168.171.2/24 as follows:

   # /root/start-network 192.168.171.2/24

If you have installed multiple NICs or are in a state where the T6 is already
in mission mode, you may need to specify the datalink you wish to use.  An
I210 will be named igbN (where N is an integer index starting at 0) and an
82574 e1000gN.  To see the available NICs, you can use:

   # dladm show-link

By default, start-network will use the first link in the list.  This is just a
crappy shell script (as are most of the rest of the steps) so you can look at
what it's doing by:

   # cat /root/start-network

If you need access to the Internet (or other networks) from the Gimlet, you
can add static routes as required at this point; for example,

   # route add default 192.168.171.1

Make sure the Gimlet and your laptop (or other necessary hosts) can
communicate:

   # ping 192.168.171.1
   $ ping 192.168.171.2

You should also be able to reach the Gimlet using ssh:

   $ ssh root@192.168.171.2

14. If your Gimlet doesn't have any M.2 SSDs installed, skip to step 15.  If
you do have one or more M.2 SSDs, it's time to get them working.  Start with:

   # nvmeadm list

Ideally, all SSDs in the machine will appear in this list; for example, with 2
of each form factor installed, you might see:

nvme3: model: Micron_7300_MTFDHBG1T9TDF, serial: 203130082CFB, FW rev: 95420260, NVMe v1.3
  nvme3/00a0750130082cfb (c4t00A0750130082CFBd0): Size = 1831420 MB, Capacity = 1831420 MB, Used = 1831420 MB
nvme0: model: Micron_7300_MTFDHBG1T9TDF, serial: 203130082D21, FW rev: 95420260, NVMe v1.3
  nvme0/00a0750130082d21 (c1t00A0750130082D21d0): Size = 1831420 MB, Capacity = 1831420 MB, Used = 1831420 MB
nvme1: model: WUS4C6432DSP3X3, serial: A079E06E, FW rev: R2210000, NVMe v1.3
  nvme1/0014ee81000bc21a (c2t0014EE81000BC21Ad0): Size = 3052360 MB, Capacity = 3052360 MB, Used = 3052360 MB
nvme2: model: WUS4C6432DSP3X3, serial: A079E264, FW rev: R2210000, NVMe v1.3
  nvme2/0014ee81000bc37c (c3t0014EE81000BC37Cd0): Size = 3052360 MB, Capacity = 3052360 MB, Used = 3052360 MB

If you have started from A4, it is likely that you see no output.  If you did
not, you may see a subset of the SSDs that are actually installed.  In either
case, you need to get them into the working state before using them; see
"Setting Up PCIe Devices" below to work around hardware-gimlet#1701 and
stlouis#57.  If only M.2A is in the broken state, you can do

   # /root/fix-m2a

This program will instruct you to execute a pair of humility commands on your
laptop that will cycle the power to M.2A.  When you have completed these
commands, press <ENTER> to finish the workaround.  If other SSDs are missing,
perform the appropriate steps manually as described in the PCIe device setup
section.  With that complete, all installed SSDs should be visible via
'nvmeadm list'.  If not, you will need to stop and debug the problem.

16. If you have previously chosen to persist phase2 data onto an installed
SSD, skip to step 19.  Otherwise, if you are following paths <A> or <B>, skip
to step 17.  If you are following path <C>, save your phase2 software into
/tmp.  First you must identify the SSD on which you previously stored the
software.  You can examine the SSDs' metadata using nvmeadm's 'list' and
'info' subcommands:

   # nvmeadm list
   # nvmeadm identify nvme2

When you have identified the correct device to use, note/copy its device path,
which will be something like 'c1t00A0750130082D21d0'.  Then extract the phase2
software you previously stored in step 1:

   # cd /tmp
   # tar xf /dev/dsk/c1t00A0750130082D21d0

You should now see several directories in /tmp, among them 'usr'.  If not, or
if this command fails, most likely you have chosen the wrong SSD.  Go back to
the beginning of this step and find the correct one, then perform the
extraction.

17. If you are following paths <A> or <B>, it is time to transfer the phase2
software onto the Gimlet over the network; be sure to substitute the IP
address you configured in step 13:

   $ scp phase2.tar root@192.168.171.2:/tmp

Make sure the file is present:

   # ls /tmp/phase2.tar

Extract the contents:

   # cd /tmp
   # tar xf phase2.tar

18. At this point, regardless of which path you are following, you should have
phase2 software unpacked in /tmp and, if you installed a NIC, access to your
Gimlet over Ethernet.  If you have an SSD installed (paths <A> or <C>), you
have the option of persisting your phase2 software onto the SSD.  Doing this
will allow you to skip steps 16, 17, and 18 on subsequent boots provided you
leave that SSD installed.  If you don't have an SSD installed or don't want to
persist phase2 software, skip to step 19.  Otherwise, start by creating a pool
and filesystem on the SSD you wish to use (see step 16 for notes on
identifying SSDs; if you are following path <C> you can overwrite the data on
the SSD you used in previous steps, or use a different one):

   # zpool create -f boot /dev/dsk/c1t00A0750130082D21d0
   # zfs create boot/phase2

Copy the phase2 data from /tmp:

   # cp -rP /tmp/* /boot/phase2

19. Finally, set up your environment to use phase2 software.  The
/root/post-phase2 script takes an argument specifying the location of phase2
software; if you chose to persist that software, it is located in /boot/phase2
(or whatever location you chose in step 18); otherwise, it is located in /tmp:

   # /root/post-phase2 /boot/phase2

This will set up the runtime linker and root's PATH so that phase2 software
can (usually) be found.  It will also use coreadm to save any cores that are
dumped; please save any such cores and file bugs accordingly.  The script will
instruct you to either log out and back in or to source /root/.profile to set
up your PATH properly.  Once you have done so, you have access to all phase2
software.  You can configure additional persistent data storage (such as
creating a pool on U.2 SSDs), plumb up the T6 and/or Sidecar links, and
whatever else you need to do.  If you need to load additional software, I
recommend creating a filesystem and mounting it at /opt/local; by default,
/opt/local/bin is in root's PATH and executables can be installed there.  You
may need to use crle(8) if you need to install libraries in /opt/local/lib.
In general, at this point the Gimlet behaves much like any other illumos
system; consult the manual as needed.  Note that you cannot write to /usr, but
you can use lofs(7fs) to mount over unused files and directories there.
Changes made to the root filesystem (/, /etc, /root, ...) will not persist
even if you set up persistent phase2 storage; the root filesystem is part of
phase1.

If the next step for you is to set up the T6, move down to the section
covering that procedure.

Setting Up PCIe Devices
-----------------------

If you have started from A4 as recommended, it is likely that all of your PCIe
devices will be powered down at boot (this is actually intended, though it
doesn't quite work properly yet).  If you have not, some may be powered and
working, some may be powered down, and some are probably in a broken,
inconsistent state.  To inspect the state of your devices, utter:

   # cfgadm -l

While you can and should read the manual for this rather awful tool, there are
from our perspective 4 states for each attachment point:

   unknown + empty + unconfigured	This appers to be a reliable
					indication that the slot is empty.

   unknown + connected + unconfigured	This is a bad state; see below.
					Typically this seems to happen if you
					reboot without going through A4 and
					indicates that the device has not been
					properly reset and/or that the SMU
					firmware's understanding of its state
					does not match reality.  We'll refer
					to this state as "broken" below.

   unknown + disconnected + unconfigured
   					This is the starting state for devices
					that are powered off and is what you
					should expect to see for all populated
					slots when starting from A4.  We'll
					refer to this state as "off" below.

   devtype/hp + connected + configured	This is the working state; devices in
   					this state should have drivers bound
					to them (or able to bind to them).
					We'll refer to this state as "working"
					below.  In this state, NICs are
					visible to dladm(8), SSDs are visible
					to nvmeadm(8), and so on.

Example output from cfgadm -l:

   Ap_Id                     Type         Receptacle   Occupant     Condition
   pcie0                     nvme/hp      connected    configured   ok
   pcie1                     nvme/hp      connected    configured   ok
   pcie2                     unknown      empty        unconfigured unknown
   pcie3                     unknown      empty        unconfigured unknown
   pcie4                     unknown      empty        unconfigured unknown
   pcie5                     unknown      empty        unconfigured unknown
   pcie6                     unknown      empty        unconfigured unknown
   pcie7                     unknown      empty        unconfigured unknown
   pcie8                     unknown      empty        unconfigured unknown
   pcie9                     etherne/hp   connected    configured   ok
   pcie16                    unknown      connected    unconfigured unknown
   pcie17                    nvme/hp      connected    configured   ok
   pcie18                    nvme/hp      connected    configured   ok
   pcie19                    unknown      empty        unconfigured unknown

The attachment points ("Ap_Id") for Gimlet rev B are as follows:

   0-9		Sharkfin slots N0 (A) through N9 (J)
   16 (0x10)	T6
   17 (0x11)	M.2A
   18 (0x12)	M.2B
   19 (0x13)	Sidecar connector

You should not see any attachment points of any type other than PCIe.

In the example above, I have installed the gigabit NIC in slot J or N9 and it
is in the working state (this may happen automatically if you have started up
from A2, or it may happen after you have fixed up the state).  The T6 is in
the broken state, there are 2 U.2 SSDs and both M.2 SSDs in the working state,
and the rest of the U.2 slots and the Sidecar connector are unused.

Devices in the off state can be powered up, enumerated, and (if a driver is
present) attached into the device tree simply by uttering:

   # cfgadm -c configure <Ap>

where <Ap> is an Ap_Id such as pcie9 that corresponds to the slot you want to
power up.  You should see console messages about attaching drivers, assuming
there is something supported in the slot.

Devices in the broken state require a more complicated dance to get working.
Essentially, we must first get the device into the off state.  There are
generally two steps to that, sometimes three depending upon how power control
actually works for the specific device.  The first step is to tell the OS to
disconnect the device:

   # cfgadm -c disconnect <Ap>

The second step is to remove power to the device or to at least reset it (if
there is no reliable way to remove power).  The means of doing this varies;
for sharkfin slots and M.2 sockets, one may command the MAX5970 controller to
turn off the channel; e.g., to force off M.2A while leaving M.2B under HPIO
control:

   $ humility i2c -b mid -d 0x3a -r 0x3b -w 0x8

For M.2 sockets, power is always controlled from device 0x3a on the mid bus,
register 0x3b, and the values to set are as follows (OR the desired state of A
and B together):

			M.2A	M.2B
	Force ON	0x3	0xc
	Force OFF	0x0	0x0
	HPIO control	0x2	0x8	(default)

For U.2/sharkfin sockets, power is controlled by setting register 0x3b at
address 0x38 on the front bus behind the following switches:

	N0/A	1:1
	N1/B	1:2
	N2/C	1:3
	N3/D	1:4
	N4/E	2:1
	N5/F	2:2
	N6/G	2:3
	N7/H	2:4
	N8/I	3:1
	N9/J	3:2

These controllers should have their enable register set as follows:

	Force ON	0xf
	Force OFF	0x0
	HPIO control	0xa	(default)

The T6's power is controlled by the sequencer FPGA.  It appears to be
sufficient to reset the T6 without cycling power; to do this, utter:

   $ humility spi -p 2 -n 64 -w 0,0,0x27,0xc

At this point the device should be in the off state, or close to it.  Next,
take the device out of reset and/or enable its power controller.  While it
should not be necessary to force the sharkfin or M.2 power controllers on, you
may have to do so.  For the T6 it should be sufficient to take it out of reset
by uttering:

   $ humility spi -p 2 -n 64 -w 0,0,0x27,0

If you need to force power to an SSD, do so at this time; otherwise, return
the SSD to HPIO power control.  The process for resetting and/or controlling
Tofino2 power is beyond the scope of this document.

Once you have cycled the device, bring it to the working state by uttering:

   # cfgadm -c configure <Ap>

This process can be repeated for each device you wish to enable.  There are
scripts that do most of this for you in /root/fix-m2a and /root/fix-t6 if you
need to fix the M.2A and T6, respectively; they will prompt you to perform the
appropriate cycling commands from your laptop or whatever machine is connected
to the SP.

If the device is still in a broken state or fails to configure, you will need
to stop and debug the problem, making note of any other error messages you see
such as:

   Dec 31 22:46:30 gimlet pcicfg: Not enough PCI resources to configure: /pci@58,0/pci1022,1483@1,1
   cfgadm: Hardware specific failure: configure failed
   Dec 31 22:46:30 gimlet genunix: WARNING: (pcieb40): failed to probe the Connection pcie16

There are a LOT of bugs here; while all the devices in S/N 15 have been seen
to be in a working state at the same time after following these procedures, it
is possible that a more heavily populated system will fail or that random
behaviours will cause hangs, panics, or devices ending up in persistent broken
states.  This is simply what lies in store for you here, several km beyond the
end of the graded road.  Some bugs to refer to include hardware-gimlet#1701,
stlouis#48, 49, 57, 58, and 59.

T6 Setup
--------

To get the T6 into mission mode (i.e., working), we must program the SROM and
flash.  The t6mfgadm command is used to do both, and the necessary data files
are in /root/t6.  After programming the T6 itself, we must switch it from
manufacturing into mission mode, which at present seems to require rebooting.
First you will likely need to give the hotplug engine the works, as with M2A:

   # /root/fix-t6

This program, like fix-m2a, will instruct you to run some humility commands to
cycle the T6.  Once this is done, you should have t6mfg attached, at which
point you can program the SROM and flash.  It should be necessary to do this
only the first time; on subsequent boots, this step can be skipped:

   # t6mfgadm srom write -d 0 -f /root/t6/Oxide_t6_2x100Gbase_kr_nomemory_v2.bin
   # t6mfgadm srom verify -d 0 -f /root/t6/Oxide_t6_2x100Gbase_kr_nomemory_v2.bin
   # t6mfgadm flash write -d 0 -F /root/t6/t6fw-1.26.6.0.bin
   # t6mfgadm flash verify -d 0 -F /root/t6/t6fw-1.26.6.0.bin

At this point, you'd like to think you could just enter mission mode and have
the t6mfg driver detach and the t4nex driver attach automatically.  Alas, we
aren't there yet.  You have two options: coordinated hotplug (which often
seems to time out and fail) or reboot.  To try coordinated hotplug, utter

   # cfgadm -f -c unconfigure pcie16
   # cfgadm -f -c disconnect pcie16

If these commands succeed, return to kmdb by sending a BREAK from your
terminal emulator (picocom: Ctrl-\), then issue the below command; otherwise,
you will need to reboot and then enter this command at the first kmdb prompt:

   [0]> 2d02574::wrsmn c40000
   [0]> :c

Then toggle CLD_RST_L:

   $ humility spi -p 2 -n 64 --write 0,0,0x27,0xc
   $ humility spi -p 2 -n 64 --write 0,0,0x27,0

Continue booting or running:

   [0]> :c

If you are doing coordinated hotplug, try to put the T6 into the working
state:

   # cfgadm -c configure pcie16

If this fails, you'll need to reboot and issue the above kmdb commands to put
the T6 into mission mode.

Once you're up, follow the general boot instructions to get yourself into
phase2; the T6 drivers are not part of the phase1 software bundle and you will
not be able to use the T6 until you have entered phase2.  Once in phase2, you
may need to do the hotplug dance again too; if the T6 drivers haven't attached
and cfgadm -l shows pcie16 as unconfigured, do:

   # /root/fix-t6

At this point, t4nex and cxgbe should be attached:

   # dladm show-link
   LINK        CLASS     MTU    STATE    BRIDGE     OVER
   e1000g0     phys      1500   up       --         --
   cxgbe0      phys      1500   unknown  --         --
   cxgbe1      phys      1500   unknown  --         --

You should now be able to plumb up the Ethernet links and/or do other useful
things with dladm etc.

Sidecar Setup
-------------

You're going to be on your own here.  The tofino(7d) and tfport(7d) drivers
are included in the phase2 bundle, along with the necessary userland changes
to make use of tfport(7d).  You may need to do something similar to the M2A/T6
fixup (cfgadm -c disconnect, cycle device power/PERST, cfgadm -c configure) in
order to make it work if the SMU firmware is confused and/or PERST is not
working properly.

*** Original Notes for illumos Engineers ***

Steps:

1. Build the kernel, modules, and kmdb and its dependencies.  The kmdb deps
are a pain if you haven't set up a bunch of ancillary crap to build userland
(in particular, Python.h seems to come up a lot).  If you have nightly(1onbld)
working, that should work fine for building all the modules you need.  If you
want to build on an arbitrary build machine using adjuncts, consider applying
illumos-build-fixes.diff from this directory.

2. Build a ramdisk.  The size in mkrd.bash must match the end address property
value in usr/src/uts/oxide/os/boot_data.c; if you need to grow the ramdisk,
change both of these!  This program outputs the name of the ramdisk image; it
uses a temporary name because even though these are internal build machines
and basically single-user we try to avoid glaring security holes; if you want
to use a fixed name you can do something like:

	$ mv $(./mkrd.bash) /path/to/ramdisk.ufs

3. Build nanobl-rs and burn it to your test machine's boot flash.  See the
instructions in that repo's README.

4. At this point you should have:
	- A box sitting at the > prompt in your terminal emulator (see
	  nanobl-rs repo for notes on configuring it)
	- A copy of unix from $ROOT/platform/kernel/oxide/amd64/unix
	- A copy of ramdisk.ufs or whatever you called it

Note that we currently need unix in the ramdisk and outside it; this
requirement can eventually be relaxed because we actually have the ELF image
in memory and the loader could tell krtld where to find it to look up symbols.
That will save about 2 MiB in the image, but for now you need it twice, and
the file in the ramdisk MUST MATCH the kernel you boot; otherwise krtld will
complain and you will not get very far.

5. If you are using a rev A Gimlet and want a NIC and/or SSD(s), you must now
power on any sharkfin power controllers you need, then release PERST# for each
PCIe end device you wish to use.  Releasing PERST# requires hardware
modification; ask if you don't know what to do.  These steps may be done in
parallel with ramdisk loading (next step).

6. Now issue the following sequence of loader commands:

	> 101000000::recv -m

	Send the ramdisk you built previously via your terminal emulator's
Xmodem upload command at this time.  This command places the ramdisk into
memory at 1_0100_0000, which must match the address in oxide/os/boot_data.c.
Note that if you build a ramdisk larger than 64 MiB, you will also need to map
memory manually or specify the size in bytes on the loader command line.  See
the help for ::recv's -m option.

	> 100000000::recv -m | ::load | ::call

	Send unix in the same manner at this time.  You are free to put this
almost anywhere that the loader will let you, except for the area the ramdisk
already occupies and the regions the kernel itself wants to be loaded into.
The suggested address is convenient and out of the way and should work on
every supportable Gimlet and Ethanol-X.  When the file receiption completes,
::load and ::call will interpret the kernel and an ELF object and transfer
control to its entry point, booting the OS.  NOTE: This syntax is available
only in nanobl-rs 0.4.1 and later.  If you have 0.4.0, you can still boot but
will need to issue three separate commands instead of a single pipeline.

6. If you wish to proceed to userland, utter ':c' when kmdb loads, ignoring
any errors about failure to load kmods.  Otherwise, begin your debug session.

7. Upon reaching userland, if you have a NIC you can plumb up your network
links and routes, then utter '/root/start-sshd' to gain remote access.  The
collection of available phase-1 system software is very limited and heavily
skewed toward debugging tools.  If you want a more functional (RFD 241
"phase-2") system, build yourself a tarball from your proto area by doing
something like:

	$ cd $ROOT; tar cf phase2.tar kernel/drv kernel/fs kernel/misc \
	  usr/lib/devfsadm usr/bin usr/lib/lib* usr/lib/amd64/lib* usr/sbin \
	  kernel/strmod sbin/zpool sbin/zfs usr/xpg6/bin usr/lib/cfgadm \
	  lib/lib* lib/amd64/lib* lib/64 usr/lib/64 usr/lib/security
	$ scp phase2.tar root@gimlet:/tmp
	gimlet:~# cd /tmp && tar xpf phase2.tar
	gimlet:~# /root/post-phase2

The root user's environment is set up so that the stuff in /tmp/bin and so
forth will be on the PATH and libraries can generally be found.  You can of
course add or change the contents to suit your needs; the above will be enough
to give you working zpool and zfs commands so if you have storage you can now
create or import a pool, making it convenient to persist data across reboots
for debugging or V&V, store larger toolsets, etc.  All of this is definitely
not complete or perfect and some things probably still won't work; you are at
the end of the graded road so grab your illumos man pages and work it out for
yourself.

8. If you wish to re-enter kmdb, send a BREAK using your terminal emulator
(picocom default: C-a C-|).  There is currently no way to reboot.  On Gimlet,
use humility to cycle through A2.  On Eth-X, ipmitool or the web UI may be
used.

Next steps:

There are many, many things to do next, and the good news is that there is
enough parallelism here for 8-10 engineers.  A few examples:

- Unmap the loader's text, data, and miscellany.  At present, we know where
  the pagetables and earlyboot stack are, and the loader has set bit 11 in all
PTEs for the kernel, so we should be able to delete these mappings if we wish.
Regardless, they end up getting unmapped and the underlying pages freed later
in boot.

- Figure out how to turn off the three reserved regions of RAM the PSP wants.

- Set the magic undocumented MSRs for the BSP, and add code to MP startup to
  do it on APs once we get there.  This probably belongs in apix, which is a
much bigger can of worms.

- Fix up the boot time properties code so we can accept the root pointer as a
  physical address, or decide that we don't ever want the loader passing boot
properties and just have it pass the ramdisk location.  There are several ways
to do this and we should take a little time to think it through -- in
particular, how offsets/pointers internally to the properties are represented.
Doing 1275 is an option here though a read through that standard suggests far
more complexity than we want or need.

- Replace boot_data.c with RPC calls to the SP.

- We can remove more of the bootaux code if we want.  The kernel's ELF object
  is in memory, and we could have the loader tell us where it is if we wanted
to.  If we were clever we could even dispense with copying the contents and
just load it in the right place, then create the proper mappings.  You know,
like a loader.  See the notes above on step 4.

- Switch us to a compressed CPIO ramdisk.  We're certain to need it to save
  space, and probably time.  Even with just gzip, the existing 13 MiB ramdisk
that is very nearly enough to get to userland fits in about 4 MiB compressed,
which is shockingly comparable to LinuxBoot, though it doesn't include any
actual user programs.  This also offers us another path to simplify booting
into a single step, by including the kernel and having the loader extract it
from the archive instead of making them separate steps; we wouldn't want to
make the loader understand UFS but CPIO might be ok.

- Probably rewrite mlsetup(), which is needlessly complicated for our needs.

- Commonise the rest of the microcode updating code.  Being able to upgrade
  microcode will be one of the very first things we want to do, so we don't
chase ghosts once we have single-user up.

- Commonise (most?  all?) the x86 HAT code.  This is current machine arch
  specific but most of it is really not.  This is in fact the same thing they
found with SPARC when they created the sfmmu directory.

- Audit and remove all the -Nmisc/acpica and other -Ndrv/acpidrv etc.
  arguments.  This should be quick and simple, but removing the code that
actually consumes these interfaces won't be.  In most cases that code needs to
be rewritten entirely but that needs to be audited on a case by case basis;
there are likely to be places where we want to share most code that currently
consumes ACPI and it may be good to create a set of ops vectors or whatever
that allow generic consumers to use ACPI or go direct (similar to platmod/PSM,
probably, or we may even be able to just extend that interface to cover
multiple machine architectures).

- Delete the rebooting code, which doesn't work anyway.  Negotiate a
  communication mechanism with the SP that can be used to request a reset from
both earlyboot and a normal working system (i.e., this can't rely solely on
STREAMS or something like that).  Stuff like `pc_reset` needs to move to
i86pc.
